/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ts/corolla.ts":
/*!***************************!*\
  !*** ./src/ts/corolla.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Corolla = void 0;
var noise_1 = __webpack_require__(/*! ./noise */ "./src/ts/noise.ts");
var parameters_1 = __webpack_require__(/*! ./parameters */ "./src/ts/parameters.ts");
var color_1 = __webpack_require__(/*! ./plotting/color */ "./src/ts/plotting/color.ts");
function randomColor() {
    var random = noise_1.Noise.randomInRange(0, 3);
    var randomChannel = Math.floor(0.5 * 255 * (random % 1));
    if (random < 1) {
        return new color_1.Color(255, 0, 255 - randomChannel);
    }
    else if (random < 2) {
        return new color_1.Color(255, randomChannel, 0);
    }
    else if (random < 3) {
        return new color_1.Color(255 - randomChannel, 255, 0);
    }
    else if (random < 4) {
        return new color_1.Color(0, 255, randomChannel);
    }
    else if (random < 5) {
        return new color_1.Color(0, 255 - randomChannel, 255);
    }
    else {
        return new color_1.Color(randomChannel, 0, 255);
    }
}
var PETALS_DROP_RATE = 0.1;
var Corolla = (function () {
    function Corolla() {
        this.position = { x: 0, y: 0 };
        this.color = randomColor();
        this.attachedPetals = this.computePetals(10);
        this.floatingPetals = [];
        this.outline = Corolla.computeOutline(40, 20);
        this.noise = new noise_1.Noise(noise_1.Noise.randomInRange(1, 2));
    }
    Corolla.prototype.update = function (dt) {
        if (this.attachedPetals.length > 0 && Math.random() < PETALS_DROP_RATE * dt) {
            var newFreePetal = this.attachedPetals.pop();
            this.registerFloatingPetal(newFreePetal);
        }
        for (var _i = 0, _a = this.floatingPetals; _i < _a.length; _i++) {
            var detachedPetal = _a[_i];
            detachedPetal.center.y -= 0.05 * detachedPetal.petalArea * dt;
            detachedPetal.orientation += detachedPetal.rotationSpeed * dt;
        }
        this.trimFloatingPetals();
        this.wind = this.noise.compute(dt);
        this.wind.x = parameters_1.Parameters.wind * 10000 * (this.wind.x - 0.5);
        this.wind.y = 1000 * (this.wind.y - 0.5);
    };
    Corolla.prototype.draw = function (plotter) {
        this.drawOutline(plotter);
        this.drawPetals(plotter);
    };
    Corolla.prototype.getAcceleration = function (forceField) {
        var acceleration = { x: 0, y: 0 };
        acceleration.x += this.wind.x * Math.min(1, this.attachedPetals.length / 16);
        acceleration.y += this.wind.y;
        var DOWNWARD_FORCE = 10000;
        var UPWARD_FORCE = [7000, 10000, 11000, 12000];
        acceleration.y += DOWNWARD_FORCE - UPWARD_FORCE[Math.min(UPWARD_FORCE.length - 1, this.attachedPetals.length)];
        var fieldForce = forceField.computeForce(this.position);
        acceleration.x += 2000 * fieldForce.x;
        acceleration.y += 2000 * fieldForce.y;
        return acceleration;
    };
    Corolla.prototype.isDead = function (lowestAllowed) {
        return this.attachedPetals.length <= 0 && this.floatingPetals.length <= 0 && this.position.y > lowestAllowed + 50;
    };
    Corolla.prototype.drawPetals = function (plotter) {
        var allPetals = this.attachedPetals.concat(this.floatingPetals);
        var color = parameters_1.Parameters.singlePetalColor ? parameters_1.Parameters.petalColor : this.color;
        plotter.drawEllipses(allPetals, color);
    };
    Corolla.prototype.drawOutline = function (plotter) {
        plotter.drawPolygon(this.outline, this.position);
    };
    Corolla.prototype.trimFloatingPetals = function () {
        for (var iP = this.floatingPetals.length - 1; iP >= 0; iP--) {
            var highestPoint = this.floatingPetals[iP].center.y + 0.5 * Math.max(this.floatingPetals[iP].width, this.floatingPetals[iP].height);
            if (highestPoint < 0) {
                this.floatingPetals.splice(iP, 1);
                iP--;
            }
        }
    };
    Corolla.prototype.registerFloatingPetal = function (petal) {
        var floatingPetal = petal;
        floatingPetal.center = { x: this.position.x, y: this.position.y };
        floatingPetal.petalArea = floatingPetal.width * floatingPetal.height;
        floatingPetal.rotationSpeed = noise_1.Noise.randomInRange(-1.5, 1.5);
        this.floatingPetals.push(floatingPetal);
    };
    Corolla.prototype.computePetals = function (nbPetals) {
        var result = [];
        for (var i = 0; i < nbPetals; i++) {
            var width = noise_1.Noise.randomInRange(50, 70);
            var proportions = noise_1.Noise.randomInRange(0.3, 0.7);
            var height = proportions * width;
            var orientation_1 = noise_1.Noise.randomInRange(0, 2 * Math.PI);
            result.push({
                width: width,
                height: height,
                orientation: orientation_1,
                center: this.position,
            });
        }
        return result;
    };
    Corolla.computeOutline = function (outlineNbPoints, outlineRadius) {
        var result = [];
        for (var i = 0; i < outlineNbPoints; i++) {
            var angle = 2 * Math.PI * i / (outlineNbPoints - 1);
            var radius = outlineRadius * noise_1.Noise.randomInRange(1, 1.3);
            result.push({
                x: radius * Math.cos(angle),
                y: radius * Math.sin(angle),
            });
        }
        return result;
    };
    return Corolla;
}());
exports.Corolla = Corolla;


/***/ }),

/***/ "./src/ts/flower.ts":
/*!**************************!*\
  !*** ./src/ts/flower.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Flower = void 0;
var corolla_1 = __webpack_require__(/*! ./corolla */ "./src/ts/corolla.ts");
var parameters_1 = __webpack_require__(/*! ./parameters */ "./src/ts/parameters.ts");
var rope_1 = __webpack_require__(/*! ./rope */ "./src/ts/rope.ts");
var Flower = (function () {
    function Flower(attachPoint, length) {
        this.attachPoint = attachPoint;
        var nbNodes = Math.max(length / Flower.maxSegmentLength);
        this.stem = new rope_1.Rope(attachPoint, length / nbNodes, nbNodes);
        this.corolla = new corolla_1.Corolla();
        this.attachCorolla();
    }
    Flower.prototype.update = function (dt, forceField) {
        this.corolla.update(dt);
        var corollaAcceleration = this.corolla.getAcceleration(forceField);
        this.stem.dampening = parameters_1.Parameters.dampening;
        this.stem.update(dt, this.attachPoint, corollaAcceleration);
        this.attachCorolla();
    };
    Flower.prototype.getDrawableStem = function () {
        return this.stem.getDrawableLine(5);
    };
    Flower.prototype.drawCorolla = function (plotter) {
        this.corolla.draw(plotter);
    };
    Flower.prototype.isDead = function (lowestAllowed) {
        return this.corolla.isDead(lowestAllowed) && this.stem.highestPoint >= lowestAllowed;
    };
    Flower.prototype.attachCorolla = function () {
        this.corolla.position.x = this.stem.endPosition.x;
        this.corolla.position.y = this.stem.endPosition.y;
    };
    Flower.maxSegmentLength = 20;
    return Flower;
}());
exports.Flower = Flower;


/***/ }),

/***/ "./src/ts/flowers-manager.ts":
/*!***********************************!*\
  !*** ./src/ts/flowers-manager.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlowersManager = void 0;
var flower_1 = __webpack_require__(/*! ./flower */ "./src/ts/flower.ts");
var noise_1 = __webpack_require__(/*! ./noise */ "./src/ts/noise.ts");
var parameters_1 = __webpack_require__(/*! ./parameters */ "./src/ts/parameters.ts");
var FlowersManager = (function () {
    function FlowersManager() {
        this.flowers = [];
    }
    FlowersManager.prototype.reset = function () {
        this.flowers.length = 0;
    };
    FlowersManager.prototype.manage = function (domainWidth, domainHeight) {
        var idealNumberOfFlowers = Math.round(domainWidth * parameters_1.Parameters.flowersDensity);
        if (idealNumberOfFlowers <= 0) {
            idealNumberOfFlowers = 1;
        }
        while (this.flowers.length < idealNumberOfFlowers) {
            var newFlower = FlowersManager.createFlower(domainWidth, domainHeight);
            this.flowers.push(newFlower);
        }
        for (var iF = this.flowers.length - 1; iF >= 0; iF--) {
            if (this.flowers[iF].isDead(domainHeight)) {
                if (this.flowers.length > idealNumberOfFlowers) {
                    this.flowers.splice(iF, 1);
                    iF--;
                }
                else {
                    this.flowers[iF] = FlowersManager.createFlower(domainWidth, domainHeight);
                }
            }
        }
    };
    FlowersManager.prototype.update = function (dt, forceField) {
        for (var _i = 0, _a = this.flowers; _i < _a.length; _i++) {
            var flower = _a[_i];
            flower.update(dt, forceField);
        }
    };
    FlowersManager.prototype.draw = function (plotter) {
        var stems = [];
        for (var _i = 0, _a = this.flowers; _i < _a.length; _i++) {
            var flower = _a[_i];
            stems.push(flower.getDrawableStem());
        }
        plotter.drawLines(stems);
        for (var _b = 0, _c = this.flowers; _b < _c.length; _b++) {
            var flower = _c[_b];
            flower.drawCorolla(plotter);
        }
    };
    FlowersManager.createFlower = function (domainWidth, domainHeight) {
        var attachPoint = {
            x: domainWidth * Math.random(),
            y: domainHeight,
        };
        var flowerLength = noise_1.Noise.randomInRange(0.2, 0.8) * domainHeight;
        return new flower_1.Flower(attachPoint, flowerLength);
    };
    return FlowersManager;
}());
exports.FlowersManager = FlowersManager;


/***/ }),

/***/ "./src/ts/force-field.ts":
/*!*******************************!*\
  !*** ./src/ts/force-field.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ForceField = void 0;
var parameters_1 = __webpack_require__(/*! ./parameters */ "./src/ts/parameters.ts");
var ForceField = (function () {
    function ForceField(mousePosition, maxInfluenceDistance) {
        this.mousePosition = mousePosition;
        this.maxInfluenceDistance = maxInfluenceDistance;
        this.fleeMouseEnabled = parameters_1.Parameters.fleeMouse;
    }
    ForceField.prototype.computeForce = function (location) {
        if (!this.fleeMouseEnabled) {
            return { x: 0, y: 0 };
        }
        var fromMouseX = location.x - this.mousePosition.x;
        var fromMouseY = location.y - this.mousePosition.y;
        var distanceToMouse = Math.sqrt(fromMouseX * fromMouseX + fromMouseY * fromMouseY);
        if (distanceToMouse > this.maxInfluenceDistance) {
            return { x: 0, y: 0 };
        }
        var mouseInfluence = 0.5 + Math.cos(Math.PI * distanceToMouse / this.maxInfluenceDistance);
        return {
            x: mouseInfluence * mouseInfluence * fromMouseX / distanceToMouse,
            y: mouseInfluence * mouseInfluence * fromMouseY / distanceToMouse,
        };
    };
    return ForceField;
}());
exports.ForceField = ForceField;


/***/ }),

/***/ "./src/ts/gl-utils/gl-canvas.ts":
/*!**************************************!*\
  !*** ./src/ts/gl-utils/gl-canvas.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.gl = exports.initGL = exports.adjustSize = void 0;
__webpack_require__(/*! ../page-interface-generated */ "./src/ts/page-interface-generated.ts");
var gl = null;
exports.gl = gl;
function initGL(flags) {
    function setError(message) {
        Page.Demopage.setErrorMessage("webgl-support", message);
    }
    var canvas = Page.Canvas.getCanvas();
    exports.gl = gl = canvas.getContext("webgl", flags);
    if (gl == null) {
        exports.gl = gl = canvas.getContext("experimental-webgl", flags);
        if (gl == null) {
            setError("Your browser or device does not seem to support WebGL.");
            return false;
        }
        setError("Your browser or device only supports experimental WebGL.\nThe simulation may not run as expected.");
    }
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
    gl.clearColor(0, 0, 0, 1);
    return true;
}
exports.initGL = initGL;
function adjustSize(hidpi) {
    if (hidpi === void 0) { hidpi = false; }
    var cssPixel = (hidpi) ? window.devicePixelRatio : 1;
    var canvas = gl.canvas;
    var width = Math.floor(canvas.clientWidth * cssPixel);
    var height = Math.floor(canvas.clientHeight * cssPixel);
    if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
    }
}
exports.adjustSize = adjustSize;


/***/ }),

/***/ "./src/ts/gl-utils/gl-resource.ts":
/*!****************************************!*\
  !*** ./src/ts/gl-utils/gl-resource.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GLResource = void 0;
var GLResource = (function () {
    function GLResource(gl) {
        this._gl = gl;
    }
    GLResource.prototype.gl = function () {
        return this._gl;
    };
    return GLResource;
}());
exports.GLResource = GLResource;


/***/ }),

/***/ "./src/ts/gl-utils/shader-manager.ts":
/*!*******************************************!*\
  !*** ./src/ts/gl-utils/shader-manager.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteShader = exports.registerShader = exports.getShader = exports.buildShader = void 0;
var gl_canvas_1 = __webpack_require__(/*! ./gl-canvas */ "./src/ts/gl-utils/gl-canvas.ts");
var shader_1 = __webpack_require__(/*! ./shader */ "./src/ts/gl-utils/shader.ts");
var ShaderSources = __importStar(__webpack_require__(/*! ./shader-sources */ "./src/ts/gl-utils/shader-sources.ts"));
var cachedShaders = {};
function getShader(name) {
    return cachedShaders[name].shader;
}
exports.getShader = getShader;
function buildShader(infos, callback) {
    var sourcesPending = 2;
    var sourcesFailed = 0;
    function loadedSource(success) {
        function processSource(source) {
            return source.replace(/#INJECT\((.*)\)/mg, function (match, name) {
                if (infos.injected[name]) {
                    return infos.injected[name];
                }
                return match;
            });
        }
        sourcesPending--;
        if (!success) {
            sourcesFailed++;
        }
        if (sourcesPending === 0) {
            var shader = null;
            if (sourcesFailed === 0) {
                var vert = ShaderSources.getSource(infos.vertexFilename);
                var frag = ShaderSources.getSource(infos.fragmentFilename);
                var processedVert = processSource(vert);
                var processedFrag = processSource(frag);
                shader = new shader_1.Shader(gl_canvas_1.gl, processedVert, processedFrag);
            }
            callback(shader);
        }
    }
    ShaderSources.loadSource(infos.vertexFilename, loadedSource);
    ShaderSources.loadSource(infos.fragmentFilename, loadedSource);
}
exports.buildShader = buildShader;
function registerShader(name, infos, callback) {
    function callAndClearCallbacks(cached) {
        for (var _i = 0, _a = cached.callbacks; _i < _a.length; _i++) {
            var cachedCallback = _a[_i];
            cachedCallback(!cached.failed, cached.shader);
        }
        cached.callbacks = [];
    }
    if (typeof cachedShaders[name] === "undefined") {
        cachedShaders[name] = {
            callbacks: [callback],
            failed: false,
            infos: infos,
            pending: true,
            shader: null,
        };
        var cached_1 = cachedShaders[name];
        buildShader(infos, function (builtShader) {
            cached_1.pending = false;
            cached_1.failed = builtShader === null;
            cached_1.shader = builtShader;
            callAndClearCallbacks(cached_1);
        });
    }
    else {
        var cached = cachedShaders[name];
        if (cached.pending === true) {
            cached.callbacks.push(callback);
        }
        else {
            callAndClearCallbacks(cached);
        }
    }
}
exports.registerShader = registerShader;
function deleteShader(name) {
    if (typeof cachedShaders[name] !== "undefined") {
        if (cachedShaders[name].shader !== null) {
            cachedShaders[name].shader.freeGLResources();
        }
        delete cachedShaders[name];
    }
}
exports.deleteShader = deleteShader;


/***/ }),

/***/ "./src/ts/gl-utils/shader-sources.ts":
/*!*******************************************!*\
  !*** ./src/ts/gl-utils/shader-sources.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadSource = exports.getSource = void 0;
var cachedSources = {};
function loadSource(filename, callback) {
    function callAndClearCallbacks(cached) {
        for (var _i = 0, _a = cached.callbacks; _i < _a.length; _i++) {
            var cachedCallback = _a[_i];
            cachedCallback(!cached.failed);
        }
        cached.callbacks = [];
    }
    if (typeof cachedSources[filename] === "undefined") {
        cachedSources[filename] = {
            callbacks: [callback],
            failed: false,
            pending: true,
            text: null,
        };
        var cached_1 = cachedSources[filename];
        var xhr_1 = new XMLHttpRequest();
        xhr_1.open("GET", "./shaders/" + filename, true);
        xhr_1.onload = function () {
            if (xhr_1.readyState === 4) {
                cached_1.pending = false;
                if (xhr_1.status === 200) {
                    cached_1.text = xhr_1.responseText;
                    cached_1.failed = false;
                }
                else {
                    console.error("Cannot load '" + filename + "' shader source: " + xhr_1.statusText);
                    cached_1.failed = true;
                }
                callAndClearCallbacks(cached_1);
            }
        };
        xhr_1.onerror = function () {
            console.error("Cannot load '" + filename + "' shader source: " + xhr_1.statusText);
            cached_1.pending = false;
            cached_1.failed = true;
            callAndClearCallbacks(cached_1);
        };
        xhr_1.send(null);
    }
    else {
        var cached = cachedSources[filename];
        if (cached.pending === true) {
            cached.callbacks.push(callback);
        }
        else {
            cached.callbacks = [callback];
            callAndClearCallbacks(cached);
        }
    }
}
exports.loadSource = loadSource;
function getSource(filename) {
    return cachedSources[filename].text;
}
exports.getSource = getSource;


/***/ }),

/***/ "./src/ts/gl-utils/shader.ts":
/*!***********************************!*\
  !*** ./src/ts/gl-utils/shader.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Shader = void 0;
var gl_resource_1 = __webpack_require__(/*! ./gl-resource */ "./src/ts/gl-utils/gl-resource.ts");
function notImplemented() {
    alert("NOT IMPLEMENTED YET");
}
function bindUniformFloat(gl, location, value) {
    if (Array.isArray(value)) {
        gl.uniform1fv(location, value);
    }
    else {
        gl.uniform1f(location, value);
    }
}
function bindUniformFloat2v(gl, location, value) {
    gl.uniform2fv(location, value);
}
function bindUniformFloat3v(gl, location, value) {
    gl.uniform3fv(location, value);
}
function bindUniformFloat4v(gl, location, value) {
    gl.uniform4fv(location, value);
}
function bindUniformInt(gl, location, value) {
    if (Array.isArray(value)) {
        gl.uniform1iv(location, value);
    }
    else {
        gl.uniform1iv(location, value);
    }
}
function bindUniformInt2v(gl, location, value) {
    gl.uniform2iv(location, value);
}
function bindUniformInt3v(gl, location, value) {
    gl.uniform3iv(location, value);
}
function bindUniformInt4v(gl, location, value) {
    gl.uniform4iv(location, value);
}
function bindUniformBool(gl, location, value) {
    gl.uniform1i(location, +value);
}
function bindUniformBool2v(gl, location, value) {
    gl.uniform2iv(location, value);
}
function bindUniformBool3v(gl, location, value) {
    gl.uniform3iv(location, value);
}
function bindUniformBool4v(gl, location, value) {
    gl.uniform4iv(location, value);
}
function bindUniformFloatMat2(gl, location, value) {
    gl.uniformMatrix2fv(location, false, value);
}
function bindUniformFloatMat3(gl, location, value) {
    gl.uniformMatrix3fv(location, false, value);
}
function bindUniformFloatMat4(gl, location, value) {
    gl.uniformMatrix4fv(location, false, value);
}
function bindSampler2D(gl, location, unitNb, value) {
    gl.uniform1i(location, unitNb);
    gl.activeTexture(gl["TEXTURE" + unitNb]);
    gl.bindTexture(gl.TEXTURE_2D, value);
}
function bindSamplerCube(gl, location, unitNb, value) {
    gl.uniform1i(location, unitNb);
    gl.activeTexture(gl["TEXTURE" + unitNb]);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, value);
}
var types = {
    0x8B50: { str: "FLOAT_VEC2", binder: bindUniformFloat2v },
    0x8B51: { str: "FLOAT_VEC3", binder: bindUniformFloat3v },
    0x8B52: { str: "FLOAT_VEC4", binder: bindUniformFloat4v },
    0x8B53: { str: "INT_VEC2", binder: bindUniformInt2v },
    0x8B54: { str: "INT_VEC3", binder: bindUniformInt3v },
    0x8B55: { str: "INT_VEC4", binder: bindUniformInt4v },
    0x8B56: { str: "BOOL", binder: bindUniformBool },
    0x8B57: { str: "BOOL_VEC2", binder: bindUniformBool2v },
    0x8B58: { str: "BOOL_VEC3", binder: bindUniformBool3v },
    0x8B59: { str: "BOOL_VEC4", binder: bindUniformBool4v },
    0x8B5A: { str: "FLOAT_MAT2", binder: bindUniformFloatMat2 },
    0x8B5B: { str: "FLOAT_MAT3", binder: bindUniformFloatMat3 },
    0x8B5C: { str: "FLOAT_MAT4", binder: bindUniformFloatMat4 },
    0x8B5E: { str: "SAMPLER_2D", binder: bindSampler2D },
    0x8B60: { str: "SAMPLER_CUBE", binder: bindSamplerCube },
    0x1400: { str: "BYTE", binder: notImplemented },
    0x1401: { str: "UNSIGNED_BYTE", binder: notImplemented },
    0x1402: { str: "SHORT", binder: notImplemented },
    0x1403: { str: "UNSIGNED_SHORT", binder: notImplemented },
    0x1404: { str: "INT", binder: bindUniformInt },
    0x1405: { str: "UNSIGNED_INT", binder: notImplemented },
    0x1406: { str: "FLOAT", binder: bindUniformFloat },
};
var ShaderProgram = (function (_super) {
    __extends(ShaderProgram, _super);
    function ShaderProgram(gl, vertexSource, fragmentSource) {
        var _this = this;
        function createShader(type, source) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            var compileSuccess = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (!compileSuccess) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        _this = _super.call(this, gl) || this;
        _this.id = null;
        _this.uCount = 0;
        _this.aCount = 0;
        var vertexShader = createShader(gl.VERTEX_SHADER, vertexSource);
        var fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentSource);
        var id = gl.createProgram();
        gl.attachShader(id, vertexShader);
        gl.attachShader(id, fragmentShader);
        gl.linkProgram(id);
        var linkSuccess = gl.getProgramParameter(id, gl.LINK_STATUS);
        if (!linkSuccess) {
            console.error(gl.getProgramInfoLog(id));
            gl.deleteProgram(id);
        }
        else {
            _this.id = id;
            _this.introspection();
        }
        return _this;
    }
    ShaderProgram.prototype.freeGLResources = function () {
        _super.prototype.gl.call(this).deleteProgram(this.id);
        this.id = null;
    };
    ShaderProgram.prototype.use = function () {
        _super.prototype.gl.call(this).useProgram(this.id);
    };
    ShaderProgram.prototype.bindUniforms = function () {
        var _this = this;
        var gl = _super.prototype.gl.call(this);
        var currTextureUnitNb = 0;
        Object.keys(this.u).forEach(function (uName) {
            var uniform = _this.u[uName];
            if (uniform.value !== null) {
                if (uniform.type === 0x8B5E || uniform.type === 0x8B60) {
                    var unitNb = currTextureUnitNb;
                    types[uniform.type].binder(gl, uniform.loc, unitNb, uniform.value);
                    currTextureUnitNb++;
                }
                else {
                    types[uniform.type].binder(gl, uniform.loc, uniform.value);
                }
            }
        });
    };
    ShaderProgram.prototype.bindAttributes = function () {
        var _this = this;
        Object.keys(this.a).forEach(function (aName) {
            var attribute = _this.a[aName];
            if (attribute.VBO !== null) {
                attribute.VBO.bind(attribute.loc);
            }
        });
    };
    ShaderProgram.prototype.bindUniformsAndAttributes = function () {
        this.bindUniforms();
        this.bindAttributes();
    };
    ShaderProgram.prototype.introspection = function () {
        var gl = _super.prototype.gl.call(this);
        this.uCount = gl.getProgramParameter(this.id, gl.ACTIVE_UNIFORMS);
        this.u = {};
        for (var i = 0; i < this.uCount; i++) {
            var uniform = gl.getActiveUniform(this.id, i);
            var name_1 = uniform.name;
            this.u[name_1] = {
                loc: gl.getUniformLocation(this.id, name_1),
                size: uniform.size,
                type: uniform.type,
                value: null,
            };
        }
        this.aCount = gl.getProgramParameter(this.id, gl.ACTIVE_ATTRIBUTES);
        this.a = {};
        for (var i = 0; i < this.aCount; i++) {
            var attribute = gl.getActiveAttrib(this.id, i);
            var name_2 = attribute.name;
            this.a[name_2] = {
                VBO: null,
                loc: gl.getAttribLocation(this.id, name_2),
                size: attribute.size,
                type: attribute.type,
            };
        }
    };
    return ShaderProgram;
}(gl_resource_1.GLResource));
exports.Shader = ShaderProgram;


/***/ }),

/***/ "./src/ts/helpers.ts":
/*!***************************!*\
  !*** ./src/ts/helpers.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.downloadTextFile = void 0;
function downloadTextFile(fileName, content) {
    var fileType = "text/plain";
    var blob = new Blob([content], { type: fileType });
    if (typeof window.navigator !== "undefined" && typeof window.navigator.msSaveBlob !== "undefined") {
        window.navigator.msSaveBlob(blob, fileName);
    }
    else {
        var objectUrl_1 = URL.createObjectURL(blob);
        var linkElement = document.createElement('a');
        linkElement.download = fileName;
        linkElement.href = objectUrl_1;
        linkElement.dataset.downloadurl = fileType + ":" + linkElement.download + ":" + linkElement.href;
        linkElement.style.display = "none";
        document.body.appendChild(linkElement);
        linkElement.click();
        document.body.removeChild(linkElement);
        setTimeout(function () {
            URL.revokeObjectURL(objectUrl_1);
        }, 5000);
    }
}
exports.downloadTextFile = downloadTextFile;


/***/ }),

/***/ "./src/ts/noise.ts":
/*!*************************!*\
  !*** ./src/ts/noise.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Noise = void 0;
var Noise = (function () {
    function Noise(period) {
        this.period = period;
        this.time = 0;
        this.last = { x: 0, y: 0 };
        this.next = { x: 0, y: 0 };
        this.last = Noise.randomVector();
        this.next = Noise.randomVector();
    }
    Noise.prototype.compute = function (dt) {
        this.time += dt;
        if (this.time > this.period) {
            this.last = this.next;
            this.next = Noise.randomVector();
            this.time = this.time % this.period;
        }
        var r = this.time / this.period;
        return {
            x: this.last.x * (1 - r) + this.next.x * r,
            y: this.last.y * (1 - r) + this.next.y * r,
        };
    };
    Noise.randomInRange = function (from, to) {
        return from + (to - from) * Math.random();
    };
    Noise.randomVector = function () {
        return { x: Math.random(), y: Math.random() };
    };
    return Noise;
}());
exports.Noise = Noise;


/***/ }),

/***/ "./src/ts/page-interface-generated.ts":
/*!********************************************!*\
  !*** ./src/ts/page-interface-generated.ts ***!
  \********************************************/
/***/ (function() {




/***/ }),

/***/ "./src/ts/parameters.ts":
/*!******************************!*\
  !*** ./src/ts/parameters.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Parameters = void 0;
__webpack_require__(/*! ./page-interface-generated */ "./src/ts/page-interface-generated.ts");
var color_1 = __webpack_require__(/*! ./plotting/color */ "./src/ts/plotting/color.ts");
var controlId = {
    FLOWERS_RANGE: "flowers-range-id",
    WIND_RANGE: "wind-range-id",
    SPEED_RANGE: "speed-range-id",
    DAMPENING_RANGE: "dampening-range-id",
    FLEE_MOUSE_CHECKBOX: "flee-mouse-checkbox-id",
    RESET_BUTTON: "reset-button-id",
    BACKGROUND_COLORPICKER: "background-color-id",
    LINES_COLORPICKER: "lines-color-id",
    SINGLE_PETAL_COLOR_CHECKBOX: "single-petal-color-checkbox-id",
    PETAL_COLORPICKER: "petal-color-id",
    DOWNLOAD_BUTTON: "download-button-id",
};
function callObservers(observers) {
    for (var _i = 0, observers_1 = observers; _i < observers_1.length; _i++) {
        var observer = observers_1[_i];
        observer();
    }
}
var resetObservers = [];
var downloadObservers = [];
function getColor(id) {
    var rgb = Page.ColorPicker.getValue(id);
    return new color_1.Color(rgb.r, rgb.g, rgb.b);
}
var backgroundColor = getColor(controlId.BACKGROUND_COLORPICKER);
Page.ColorPicker.addObserver(controlId.BACKGROUND_COLORPICKER, function () { backgroundColor = getColor(controlId.BACKGROUND_COLORPICKER); });
var linesColor = getColor(controlId.LINES_COLORPICKER);
Page.ColorPicker.addObserver(controlId.LINES_COLORPICKER, function () { linesColor = getColor(controlId.LINES_COLORPICKER); });
var petalsColor = getColor(controlId.PETAL_COLORPICKER);
Page.ColorPicker.addObserver(controlId.PETAL_COLORPICKER, function () { petalsColor = getColor(controlId.PETAL_COLORPICKER); });
var Parameters = (function () {
    function Parameters() {
    }
    Object.defineProperty(Parameters, "mousePositionInPixels", {
        get: function () {
            var mousePosition = Page.Canvas.getMousePosition();
            if (mousePosition.length === 2) {
                var canvasSize = Page.Canvas.getSize();
                return {
                    x: canvasSize[0] * mousePosition[0],
                    y: canvasSize[1] * mousePosition[1],
                };
            }
            else {
                return { x: 0, y: 0 };
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "flowersDensity", {
        get: function () {
            return Page.Range.getValue(controlId.FLOWERS_RANGE) * 0.25;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "wind", {
        get: function () {
            return Page.Range.getValue(controlId.WIND_RANGE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "speed", {
        get: function () {
            return Page.Range.getValue(controlId.SPEED_RANGE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "dampening", {
        get: function () {
            return 1 - 0.01 * Page.Range.getValue(controlId.DAMPENING_RANGE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "fleeMouse", {
        get: function () {
            return Page.Checkbox.isChecked(controlId.FLEE_MOUSE_CHECKBOX);
        },
        enumerable: false,
        configurable: true
    });
    Parameters.addResetObserver = function (observer) {
        resetObservers.push(observer);
    };
    Object.defineProperty(Parameters, "backgroundColor", {
        get: function () {
            return backgroundColor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "linesColor", {
        get: function () {
            return linesColor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "singlePetalColor", {
        get: function () {
            return Page.Checkbox.isChecked(controlId.SINGLE_PETAL_COLOR_CHECKBOX);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "petalColor", {
        get: function () {
            return petalsColor;
        },
        enumerable: false,
        configurable: true
    });
    Parameters.addDownloadObserver = function (observer) {
        downloadObservers.push(observer);
    };
    return Parameters;
}());
exports.Parameters = Parameters;
function updatePetalColorsVisibility() {
    var visible = Page.Checkbox.isChecked(controlId.SINGLE_PETAL_COLOR_CHECKBOX);
    Page.Controls.setVisibility(controlId.PETAL_COLORPICKER, visible);
}
Page.Checkbox.addObserver(controlId.SINGLE_PETAL_COLOR_CHECKBOX, updatePetalColorsVisibility);
updatePetalColorsVisibility();
Page.Button.addObserver(controlId.RESET_BUTTON, function () {
    callObservers(resetObservers);
});
Page.Button.addObserver(controlId.DOWNLOAD_BUTTON, function () {
    callObservers(downloadObservers);
});


/***/ }),

/***/ "./src/ts/plotting/color.ts":
/*!**********************************!*\
  !*** ./src/ts/plotting/color.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Color = void 0;
var Color = (function () {
    function Color(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.rNormalized = r / 255;
        this.gNormalized = g / 255;
        this.bNormalized = b / 255;
    }
    Color.prototype.toStringRGB = function () {
        return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
    };
    Color.prototype.toStringRGBA = function (alpha) {
        return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + alpha + ")";
    };
    return Color;
}());
exports.Color = Color;


/***/ }),

/***/ "./src/ts/plotting/plotter-canvas-2d.ts":
/*!**********************************************!*\
  !*** ./src/ts/plotting/plotter-canvas-2d.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlotterCanvas2D = void 0;
var plotter_canvas_base_1 = __webpack_require__(/*! ./plotter-canvas-base */ "./src/ts/plotting/plotter-canvas-base.ts");
__webpack_require__(/*! ../page-interface-generated */ "./src/ts/page-interface-generated.ts");
function ellipsePolyfill(centerX, centerY, radiusX, radiusY) {
    this.arc(centerX, centerY, Math.max(radiusX, radiusY), 0, 2 * Math.PI);
}
var PlotterCanvas2D = (function (_super) {
    __extends(PlotterCanvas2D, _super);
    function PlotterCanvas2D() {
        var _this = _super.call(this) || this;
        _this.context = _this.canvas.getContext("2d", { alpha: false });
        _this.context.lineWidth = 1;
        return _this;
    }
    PlotterCanvas2D.prototype.initializeInternal = function () {
        this.context.fillStyle = this.fillColor.toStringRGB();
        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
    };
    PlotterCanvas2D.prototype.finalize = function () { };
    PlotterCanvas2D.prototype.drawLines = function (lines) {
        if (lines.length >= 1) {
            this.context.strokeStyle = this.lineColor.toStringRGB();
            this.context.lineWidth = 1;
            this.context.beginPath();
            for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
                var line = lines_1[_i];
                if (line.length >= 2) {
                    this.context.moveTo(line[0].x * this.cssPixel, line[0].y * this.cssPixel);
                    for (var iP = 1; iP < line.length; iP++) {
                        this.context.lineTo(line[iP].x * this.cssPixel, line[iP].y * this.cssPixel);
                    }
                }
            }
            this.context.stroke();
            this.context.closePath();
        }
    };
    PlotterCanvas2D.prototype.drawPolygon = function (polygon, offset) {
        if (polygon.length >= 2) {
            this.context.fillStyle = this.fillColor.toStringRGB();
            this.context.lineWidth = 1;
            this.context.beginPath();
            this.context.moveTo((polygon[0].x + offset.x) * this.cssPixel, (polygon[0].y + offset.y) * this.cssPixel);
            for (var iP = 1; iP < polygon.length; iP++) {
                this.context.lineTo((polygon[iP].x + offset.x) * this.cssPixel, (polygon[iP].y + offset.y) * this.cssPixel);
            }
            this.context.closePath();
            this.context.fill();
            this.context.stroke();
        }
    };
    PlotterCanvas2D.prototype.drawEllipses = function (ellipses, color) {
        this.context.fillStyle = color.toStringRGBA(this.ellipseOpacity);
        if (typeof this.context.ellipse !== "function") {
            this.context.ellipse = ellipsePolyfill;
        }
        for (var _i = 0, ellipses_1 = ellipses; _i < ellipses_1.length; _i++) {
            var ellipse = ellipses_1[_i];
            this.context.beginPath();
            this.context.ellipse(ellipse.center.x * this.cssPixel, ellipse.center.y * this.cssPixel, 0.5 * ellipse.width * this.cssPixel, 0.5 * ellipse.height * this.cssPixel, ellipse.orientation, 0, 2 * Math.PI);
            this.context.fill();
            this.context.closePath();
        }
    };
    return PlotterCanvas2D;
}(plotter_canvas_base_1.PlotterCanvas));
exports.PlotterCanvas2D = PlotterCanvas2D;


/***/ }),

/***/ "./src/ts/plotting/plotter-canvas-base.ts":
/*!************************************************!*\
  !*** ./src/ts/plotting/plotter-canvas-base.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlotterCanvas = void 0;
var plotter_1 = __webpack_require__(/*! ./plotter */ "./src/ts/plotting/plotter.ts");
__webpack_require__(/*! ../page-interface-generated */ "./src/ts/page-interface-generated.ts");
var PlotterCanvas = (function (_super) {
    __extends(PlotterCanvas, _super);
    function PlotterCanvas() {
        var _a;
        var _this = _super.call(this) || this;
        _this.canvas = Page.Canvas.getCanvas();
        _this.cssPixel = (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1;
        _this.adjustToCanvas();
        return _this;
    }
    PlotterCanvas.prototype.adjustToCanvas = function () {
        var actualWidth = Math.floor(this.cssPixel * this.canvas.clientWidth);
        var actualHeight = Math.floor(this.cssPixel * this.canvas.clientHeight);
        if (this.canvas.width !== actualWidth || this.canvas.height !== actualHeight) {
            this.canvas.width = actualWidth;
            this.canvas.height = actualHeight;
        }
        this._width = this.canvas.clientWidth;
        this._height = this.canvas.clientHeight;
    };
    Object.defineProperty(PlotterCanvas.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PlotterCanvas.prototype, "height", {
        get: function () {
            return this._height;
        },
        enumerable: false,
        configurable: true
    });
    return PlotterCanvas;
}(plotter_1.Plotter));
exports.PlotterCanvas = PlotterCanvas;


/***/ }),

/***/ "./src/ts/plotting/plotter-canvas-webgl.ts":
/*!*************************************************!*\
  !*** ./src/ts/plotting/plotter-canvas-webgl.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlotterCanvasWebGL = void 0;
var plotter_canvas_base_1 = __webpack_require__(/*! ./plotter-canvas-base */ "./src/ts/plotting/plotter-canvas-base.ts");
var gl_canvas_1 = __webpack_require__(/*! ../gl-utils/gl-canvas */ "./src/ts/gl-utils/gl-canvas.ts");
var ShaderManager = __importStar(__webpack_require__(/*! ../gl-utils/shader-manager */ "./src/ts/gl-utils/shader-manager.ts"));
__webpack_require__(/*! ../page-interface-generated */ "./src/ts/page-interface-generated.ts");
var EBatchType;
(function (EBatchType) {
    EBatchType[EBatchType["LINES"] = 0] = "LINES";
    EBatchType[EBatchType["POLYGONS"] = 1] = "POLYGONS";
    EBatchType[EBatchType["ELLIPSES"] = 2] = "ELLIPSES";
})(EBatchType || (EBatchType = {}));
var PlotterCanvasWebGL = (function (_super) {
    __extends(PlotterCanvasWebGL, _super);
    function PlotterCanvasWebGL() {
        var _this = _super.call(this) || this;
        if (!gl_canvas_1.initGL()) {
            throw new Error("Failed to initialize WebGL.");
        }
        gl_canvas_1.gl.enable(gl_canvas_1.gl.BLEND);
        gl_canvas_1.gl.blendFunc(gl_canvas_1.gl.SRC_ALPHA, gl_canvas_1.gl.ONE_MINUS_SRC_ALPHA);
        gl_canvas_1.gl.enable(gl_canvas_1.gl.DEPTH_TEST);
        gl_canvas_1.gl.depthFunc(gl_canvas_1.gl.LEQUAL);
        gl_canvas_1.gl.clearDepth(1);
        _this.linesVBOId = gl_canvas_1.gl.createBuffer();
        _this.ellipsesVBOId = gl_canvas_1.gl.createBuffer();
        _this.corollaVBOId = gl_canvas_1.gl.createBuffer();
        _this.corollaIndexVBOId = gl_canvas_1.gl.createBuffer();
        ShaderManager.buildShader({
            vertexFilename: "lines.vert",
            fragmentFilename: "lines.frag",
            injected: {},
        }, function (builtShader) {
            if (builtShader === null) {
                var errorMessage = "Failed to load or build the lines shader.";
                Page.Demopage.setErrorMessage("shader-lines", errorMessage);
                throw new Error(errorMessage);
            }
            _this.linesShader = builtShader;
        });
        ShaderManager.buildShader({
            vertexFilename: "ellipses.vert",
            fragmentFilename: "ellipses.frag",
            injected: {},
        }, function (builtShader) {
            if (builtShader === null) {
                var errorMessage = "Failed to load or build the ellipses shader.";
                Page.Demopage.setErrorMessage("shader-ellipses", errorMessage);
                throw new Error(errorMessage);
            }
            _this.ellipsesShader = builtShader;
        });
        ShaderManager.buildShader({
            vertexFilename: "polygons.vert",
            fragmentFilename: "polygons.frag",
            injected: {},
        }, function (builtShader) {
            if (builtShader === null) {
                var errorMessage = "Failed to load or build the polygons shader.";
                Page.Demopage.setErrorMessage("shader-polygons", errorMessage);
                throw new Error(errorMessage);
            }
            _this.polygonsShader = builtShader;
        });
        return _this;
    }
    PlotterCanvasWebGL.prototype.initializeInternal = function () {
        gl_canvas_1.gl.viewport(0, 0, this.width * this.cssPixel, this.height * this.cssPixel);
        gl_canvas_1.gl.clearColor(this.fillColor.rNormalized, this.fillColor.gNormalized, this.fillColor.bNormalized, 1);
        gl_canvas_1.gl.clear(gl_canvas_1.gl.COLOR_BUFFER_BIT | gl_canvas_1.gl.DEPTH_BUFFER_BIT);
        this.batches = [];
    };
    PlotterCanvasWebGL.prototype.finalize = function () {
        var linesBatch = [];
        var polygonsBatch = [];
        var ellipsesBatch = [];
        for (var _i = 0, _a = this.batches; _i < _a.length; _i++) {
            var batch = _a[_i];
            if (batch.type === EBatchType.LINES) {
                linesBatch.push(batch);
            }
            else if (batch.type === EBatchType.POLYGONS) {
                polygonsBatch.push(batch);
            }
            else if (batch.type === EBatchType.ELLIPSES) {
                ellipsesBatch.push(batch);
            }
        }
        if (linesBatch.length > 0) {
            this.drawLinesBatches(linesBatch);
        }
        gl_canvas_1.gl.depthMask(true);
        if (polygonsBatch.length > 0) {
            this.drawPolygonsBatches(polygonsBatch);
        }
        gl_canvas_1.gl.depthMask(false);
        if (ellipsesBatch.length > 0) {
            this.drawEllipseBatches(ellipsesBatch);
        }
        this.batches = [];
    };
    PlotterCanvasWebGL.prototype.drawLines = function (lines) {
        var nonTrivalLines = [];
        var nbSegments = 0;
        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
            var line = lines_1[_i];
            if (line.length >= 2) {
                nbSegments += line.length - 1;
                nonTrivalLines.push(line);
            }
        }
        if (nonTrivalLines.length > 0) {
            var linesBatch = {
                type: EBatchType.LINES,
                lines: nonTrivalLines,
                nbSegments: nbSegments,
                batchId: this.batches.length,
            };
            this.batches.push(linesBatch);
        }
    };
    PlotterCanvasWebGL.prototype.drawPolygon = function (polygon, offset) {
        if (polygon.length > 0) {
            var outline = [];
            for (var _i = 0, polygon_1 = polygon; _i < polygon_1.length; _i++) {
                var point = polygon_1[_i];
                outline.push({
                    x: point.x + offset.x,
                    y: point.y + offset.y,
                });
            }
            var polygonBatch = {
                type: EBatchType.POLYGONS,
                outline: outline,
                center: offset,
                batchId: this.batches.length,
            };
            this.batches.push(polygonBatch);
        }
    };
    PlotterCanvasWebGL.prototype.drawEllipses = function (ellipses, color) {
        if (ellipses.length > 0) {
            var ellipsesBatch = {
                type: EBatchType.ELLIPSES,
                ellipsesList: ellipses,
                color: color,
                batchId: this.batches.length,
            };
            this.batches.push(ellipsesBatch);
        }
    };
    PlotterCanvasWebGL.prototype.drawLinesBatches = function (batches) {
        if (this.linesShader) {
            var totalNbSegments = 0;
            for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {
                var batch = batches_1[_i];
                totalNbSegments += batch.nbSegments;
            }
            var buffer = new Float32Array(2 * 2 * totalNbSegments);
            {
                var i = 0;
                for (var _a = 0, batches_2 = batches; _a < batches_2.length; _a++) {
                    var batch = batches_2[_a];
                    for (var _b = 0, _c = batch.lines; _b < _c.length; _b++) {
                        var line = _c[_b];
                        buffer[i++] = line[0].x;
                        buffer[i++] = line[0].y;
                        for (var iP = 1; iP < line.length - 1; iP++) {
                            buffer[i++] = line[iP].x;
                            buffer[i++] = line[iP].y;
                            buffer[i++] = line[iP].x;
                            buffer[i++] = line[iP].y;
                        }
                        buffer[i++] = line[line.length - 1].x;
                        buffer[i++] = line[line.length - 1].y;
                    }
                }
            }
            gl_canvas_1.gl.bindBuffer(gl_canvas_1.gl.ARRAY_BUFFER, this.linesVBOId);
            gl_canvas_1.gl.bufferData(gl_canvas_1.gl.ARRAY_BUFFER, buffer, gl_canvas_1.gl.DYNAMIC_DRAW);
            this.linesShader.u["uScreenSize"].value = [this.width, this.height];
            this.linesShader.u["uColor"].value = [this.lineColor.rNormalized, this.lineColor.gNormalized, this.lineColor.bNormalized, 1];
            this.linesShader.use();
            var aVertexLoc = this.linesShader.a["aVertex"].loc;
            gl_canvas_1.gl.enableVertexAttribArray(aVertexLoc);
            var FLOAT_SIZE_IN_BYTES = 4;
            var batchStartIndex = 0;
            for (var _d = 0, batches_3 = batches; _d < batches_3.length; _d++) {
                var batch = batches_3[_d];
                this.linesShader.u["uDepth"].value = this.computeBatchDepth(batch);
                this.linesShader.bindUniforms();
                gl_canvas_1.gl.vertexAttribPointer(aVertexLoc, 2, gl_canvas_1.gl.FLOAT, false, 0, 2 * batchStartIndex * FLOAT_SIZE_IN_BYTES);
                var nbVertices = 2 * batch.nbSegments;
                gl_canvas_1.gl.drawArrays(gl_canvas_1.gl.LINES, 0, nbVertices);
                batchStartIndex += nbVertices;
            }
        }
    };
    PlotterCanvasWebGL.prototype.drawPolygonsBatches = function (batches) {
        if (this.polygonsShader) {
            var totalNbVertices = 0;
            var totalNbTriangles = 0;
            var totalNbLines = 0;
            for (var _i = 0, batches_4 = batches; _i < batches_4.length; _i++) {
                var polygon = batches_4[_i];
                totalNbVertices += 1 + polygon.outline.length;
                totalNbTriangles += polygon.outline.length;
                totalNbLines += polygon.outline.length;
            }
            var verticesBuffer = new Float32Array(4 * totalNbVertices);
            {
                var iVertice = 0;
                for (var _a = 0, batches_5 = batches; _a < batches_5.length; _a++) {
                    var polygon = batches_5[_a];
                    var polygonDepth = this.computeBatchDepth(polygon);
                    verticesBuffer[iVertice++] = polygon.center.x;
                    verticesBuffer[iVertice++] = polygon.center.y;
                    verticesBuffer[iVertice++] = polygonDepth;
                    verticesBuffer[iVertice++] = 0;
                    for (var _b = 0, _c = polygon.outline; _b < _c.length; _b++) {
                        var outlinePoint = _c[_b];
                        verticesBuffer[iVertice++] = outlinePoint.x;
                        verticesBuffer[iVertice++] = outlinePoint.y;
                        verticesBuffer[iVertice++] = polygonDepth;
                        verticesBuffer[iVertice++] = 0;
                    }
                }
            }
            var indicesBuffer = new Uint16Array(2 * totalNbLines + 3 * totalNbTriangles);
            {
                var iIndex = 0;
                var iVerticeIndex = 0;
                for (var _d = 0, batches_6 = batches; _d < batches_6.length; _d++) {
                    var polygon = batches_6[_d];
                    var indexOfPolygonCenter = iVerticeIndex;
                    for (var iPoint = 0; iPoint < polygon.outline.length - 1; iPoint++) {
                        indicesBuffer[iIndex++] = indexOfPolygonCenter;
                        indicesBuffer[iIndex++] = indexOfPolygonCenter + iPoint + 1;
                        indicesBuffer[iIndex++] = indexOfPolygonCenter + iPoint + 2;
                    }
                    indicesBuffer[iIndex++] = indexOfPolygonCenter;
                    indicesBuffer[iIndex++] = indexOfPolygonCenter + polygon.outline.length;
                    indicesBuffer[iIndex++] = indexOfPolygonCenter + 1;
                    iVerticeIndex += polygon.outline.length + 1;
                }
                iVerticeIndex = 0;
                for (var _e = 0, batches_7 = batches; _e < batches_7.length; _e++) {
                    var polygon = batches_7[_e];
                    for (var iPoint = 0; iPoint < polygon.outline.length - 1; iPoint++) {
                        indicesBuffer[iIndex++] = iVerticeIndex + iPoint + 1;
                        indicesBuffer[iIndex++] = iVerticeIndex + iPoint + 2;
                    }
                    indicesBuffer[iIndex++] = iVerticeIndex + polygon.outline.length;
                    indicesBuffer[iIndex++] = iVerticeIndex + 1;
                    iVerticeIndex += polygon.outline.length + 1;
                }
            }
            this.polygonsShader.u["uScreenSize"].value = [this.width, this.height];
            this.polygonsShader.use();
            gl_canvas_1.gl.bindBuffer(gl_canvas_1.gl.ARRAY_BUFFER, this.corollaVBOId);
            gl_canvas_1.gl.bufferData(gl_canvas_1.gl.ARRAY_BUFFER, verticesBuffer, gl_canvas_1.gl.DYNAMIC_DRAW);
            var aDataLoc = this.polygonsShader.a["aData"].loc;
            gl_canvas_1.gl.enableVertexAttribArray(aDataLoc);
            gl_canvas_1.gl.vertexAttribPointer(aDataLoc, 4, gl_canvas_1.gl.FLOAT, false, 0, 0);
            gl_canvas_1.gl.bindBuffer(gl_canvas_1.gl.ELEMENT_ARRAY_BUFFER, this.corollaIndexVBOId);
            gl_canvas_1.gl.bufferData(gl_canvas_1.gl.ELEMENT_ARRAY_BUFFER, indicesBuffer, gl_canvas_1.gl.DYNAMIC_DRAW);
            this.polygonsShader.u["uColor"].value = [this.fillColor.rNormalized, this.fillColor.gNormalized, this.fillColor.bNormalized, 1];
            this.polygonsShader.bindUniforms();
            gl_canvas_1.gl.drawElements(gl_canvas_1.gl.TRIANGLES, 3 * totalNbTriangles, gl_canvas_1.gl.UNSIGNED_SHORT, 0);
            this.polygonsShader.u["uColor"].value = [this.lineColor.rNormalized, this.lineColor.gNormalized, this.lineColor.bNormalized, 2];
            this.polygonsShader.bindUniforms();
            var UNSIGNED_SHORT_SIZE_IN_BYTES = 2;
            gl_canvas_1.gl.drawElements(gl_canvas_1.gl.LINES, 2 * totalNbLines, gl_canvas_1.gl.UNSIGNED_SHORT, 3 * totalNbTriangles * UNSIGNED_SHORT_SIZE_IN_BYTES);
        }
    };
    PlotterCanvasWebGL.prototype.drawEllipseBatches = function (batches) {
        if (this.ellipsesShader) {
            var totalNbPoints = 0;
            for (var _i = 0, batches_8 = batches; _i < batches_8.length; _i++) {
                var ellipseBatch = batches_8[_i];
                totalNbPoints += ellipseBatch.ellipsesList.length;
            }
            var buffer = new Float32Array(8 * totalNbPoints);
            {
                var i = 0;
                for (var _a = 0, batches_9 = batches; _a < batches_9.length; _a++) {
                    var ellipseBatch = batches_9[_a];
                    var batchDepth = this.computeBatchDepth(ellipseBatch);
                    for (var _b = 0, _c = ellipseBatch.ellipsesList; _b < _c.length; _b++) {
                        var ellipse = _c[_b];
                        var widestSide = Math.ceil(Math.max(1, ellipse.width, ellipse.height));
                        var proportions = Math.min(ellipse.width, ellipse.height) / widestSide;
                        var encodedDimensions = Math.ceil(widestSide * this.cssPixel) + proportions;
                        buffer[i++] = ellipse.center.x;
                        buffer[i++] = ellipse.center.y;
                        buffer[i++] = encodedDimensions;
                        buffer[i++] = batchDepth;
                        buffer[i++] = ellipseBatch.color.rNormalized;
                        buffer[i++] = ellipseBatch.color.gNormalized;
                        buffer[i++] = ellipseBatch.color.bNormalized;
                        buffer[i++] = ellipse.orientation;
                    }
                }
            }
            this.ellipsesShader.u["uScreenSize"].value = [this.width, this.height];
            this.ellipsesShader.u["uPetalAlpha"].value = 0.2;
            this.ellipsesShader.use();
            this.ellipsesShader.bindUniforms();
            var BYTES_PER_FLOAT = 4;
            gl_canvas_1.gl.bindBuffer(gl_canvas_1.gl.ARRAY_BUFFER, this.ellipsesVBOId);
            gl_canvas_1.gl.bufferData(gl_canvas_1.gl.ARRAY_BUFFER, buffer, gl_canvas_1.gl.DYNAMIC_DRAW);
            var aData1Loc = this.ellipsesShader.a["aData1"].loc;
            gl_canvas_1.gl.enableVertexAttribArray(aData1Loc);
            gl_canvas_1.gl.vertexAttribPointer(aData1Loc, 4, gl_canvas_1.gl.FLOAT, false, 2 * 4 * BYTES_PER_FLOAT, 0);
            var aData2Loc = this.ellipsesShader.a["aData2"].loc;
            gl_canvas_1.gl.enableVertexAttribArray(aData2Loc);
            gl_canvas_1.gl.vertexAttribPointer(aData2Loc, 4, gl_canvas_1.gl.FLOAT, false, 2 * 4 * BYTES_PER_FLOAT, 4 * BYTES_PER_FLOAT);
            gl_canvas_1.gl.drawArrays(gl_canvas_1.gl.POINTS, 0, totalNbPoints);
        }
    };
    PlotterCanvasWebGL.prototype.computeBatchDepth = function (batch) {
        return 1.9 * (0.5 - (batch.batchId / this.batches.length));
    };
    return PlotterCanvasWebGL;
}(plotter_canvas_base_1.PlotterCanvas));
exports.PlotterCanvasWebGL = PlotterCanvasWebGL;


/***/ }),

/***/ "./src/ts/plotting/plotter-svg.ts":
/*!****************************************!*\
  !*** ./src/ts/plotting/plotter-svg.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlotterSvg = void 0;
var plotter_1 = __webpack_require__(/*! ./plotter */ "./src/ts/plotting/plotter.ts");
__webpack_require__(/*! ../page-interface-generated */ "./src/ts/page-interface-generated.ts");
function radianToDegree(radian) {
    return 180 * radian / Math.PI;
}
var PlotterSvg = (function (_super) {
    __extends(PlotterSvg, _super);
    function PlotterSvg(width, height) {
        var _this = _super.call(this) || this;
        _this.stringParts = [];
        _this.width = width;
        _this.height = height;
        return _this;
    }
    PlotterSvg.prototype.initializeInternal = function () {
        this.stringParts.push("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>");
        this.stringParts.push("<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 " + this.width + " " + this.height + "\">");
        this.stringParts.push("\t<rect fill=\"" + this.fillColor.toStringRGB() + "\" stroke=\"none\" x=\"0\" y=\"0\" width=\"" + this.width + "\" height=\"" + this.height + "\"/>");
        this.stringParts.push("\t<g fill=\"" + this.fillColor.toStringRGB() + "\" stroke=\"" + this.lineColor.toStringRGB() + "\" stroke-width=\"1\">");
    };
    PlotterSvg.prototype.finalize = function () {
        this.stringParts.push("\t</g>");
        this.stringParts.push("</svg>");
    };
    PlotterSvg.prototype.toString = function () {
        return this.stringParts.join("\n");
    };
    PlotterSvg.prototype.drawLines = function (lines) {
        if (lines.length >= 1) {
            this.stringParts.push("\t\t<g fill=\"none\">");
            for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
                var line = lines_1[_i];
                if (line.length >= 2) {
                    this.stringParts.push("\t\t\t<path d=\"" + PlotterSvg.computePath(line) + "\"/>");
                }
            }
            this.stringParts.push("\t\t</g>");
        }
    };
    PlotterSvg.prototype.drawPolygon = function (polygon, offset) {
        if (polygon.length >= 2) {
            var transform = "translate(" + offset.x.toFixed(1) + " " + offset.y.toFixed(1) + ")";
            this.stringParts.push("\t\t<path d=\"" + PlotterSvg.computePath(polygon) + "Z\" transform=\"" + transform + "\"/>");
        }
    };
    PlotterSvg.prototype.drawEllipses = function (ellipses, color) {
        if (ellipses.length >= 1) {
            this.stringParts.push("\t\t<g stroke=\"none\" fill=\"" + color.toStringRGBA(this.ellipseOpacity) + "\">");
            for (var _i = 0, ellipses_1 = ellipses; _i < ellipses_1.length; _i++) {
                var ellipse = ellipses_1[_i];
                var transform = "translate(" + ellipse.center.x.toFixed(1) + " " + ellipse.center.y.toFixed(1) + ") rotate(" + radianToDegree(ellipse.orientation).toFixed(1) + ")";
                this.stringParts.push("\t\t\t<ellipse cx=\"0\" cy=\"0\" rx=\"" + (0.5 * ellipse.width).toFixed(1) + "\" ry=\"" + (0.5 * ellipse.height).toFixed(1) + "\" transform=\"" + transform + "\"/>");
            }
            this.stringParts.push("\t\t</g>");
        }
    };
    PlotterSvg.computePath = function (line) {
        var start = "M" + line[0].x.toFixed(1) + "," + line[0].y.toFixed(1) + "L";
        var pathParts = [];
        for (var iP = 1; iP < line.length; iP++) {
            pathParts.push(line[iP].x.toFixed(1) + "," + line[iP].y.toFixed(1));
        }
        return start + pathParts.join(" ");
    };
    return PlotterSvg;
}(plotter_1.Plotter));
exports.PlotterSvg = PlotterSvg;


/***/ }),

/***/ "./src/ts/plotting/plotter.ts":
/*!************************************!*\
  !*** ./src/ts/plotting/plotter.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Plotter = void 0;
__webpack_require__(/*! ../page-interface-generated */ "./src/ts/page-interface-generated.ts");
var Plotter = (function () {
    function Plotter() {
    }
    Plotter.prototype.initialize = function (fillColor, lineColor, ellipseOpacity) {
        this.fillColor = fillColor;
        this.lineColor = lineColor;
        this.ellipseOpacity = ellipseOpacity;
        this.initializeInternal();
    };
    return Plotter;
}());
exports.Plotter = Plotter;


/***/ }),

/***/ "./src/ts/rope.ts":
/*!************************!*\
  !*** ./src/ts/rope.ts ***!
  \************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Rope = void 0;
function createRopeNode(x, y) {
    return {
        pos: { x: x, y: y },
        previousPos: { x: x, y: y },
        acc: { x: 0, y: 0 },
    };
}
var NB_ITERATIONS = 8;
var Rope = (function () {
    function Rope(startingPoint, segmentLength, nbNodes) {
        this.dampening = 1;
        this.segmentLength = segmentLength;
        this.totalLength = segmentLength * nbNodes;
        this.nodes = [];
        this.nodes.push(createRopeNode(startingPoint.x, startingPoint.y));
        for (var iN = 0; iN < nbNodes; iN++) {
            var angle = 2 * Math.PI * Math.random();
            this.nodes.push(createRopeNode(this.nodes[this.nodes.length - 1].pos.x + segmentLength * Math.cos(angle), this.nodes[this.nodes.length - 1].pos.y + Math.abs(segmentLength * Math.sin(angle))));
        }
    }
    Rope.prototype.getDrawableLine = function (minSegmentLength) {
        return this.computeSmoothLine(this.totalLength / minSegmentLength);
    };
    Rope.prototype.update = function (dt, origin, endAcceleration) {
        this.applyForces(endAcceleration);
        this.applyVerlet(dt);
        for (var i = 0; i < NB_ITERATIONS; i++) {
            this.applyConstraints(origin);
        }
    };
    Object.defineProperty(Rope.prototype, "endPosition", {
        get: function () {
            return this.nodes[this.nodes.length - 1].pos;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rope.prototype, "highestPoint", {
        get: function () {
            var highest = 1000000;
            for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {
                var node = _a[_i];
                if (node.pos.y < highest) {
                    highest = node.pos.y;
                }
            }
            return highest;
        },
        enumerable: false,
        configurable: true
    });
    Rope.prototype.applyForces = function (endAcceleration) {
        for (var iN = 1; iN < this.nodes.length; iN++) {
            this.nodes[iN].acc.x = 0;
            this.nodes[iN].acc.y = 0;
        }
        this.nodes[this.nodes.length - 1].acc.x += endAcceleration.x;
        this.nodes[this.nodes.length - 1].acc.y += endAcceleration.y;
    };
    Rope.prototype.applyVerlet = function (dt) {
        for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {
            var node = _a[_i];
            var newPosX = node.pos.x + this.dampening * (node.pos.x - node.previousPos.x) + dt * dt * node.acc.x;
            var newPosY = node.pos.y + this.dampening * (node.pos.y - node.previousPos.y) + dt * dt * node.acc.y;
            node.previousPos.x = node.pos.x;
            node.previousPos.y = node.pos.y;
            node.pos.x = newPosX;
            node.pos.y = newPosY;
        }
    };
    Rope.prototype.applyConstraints = function (origin) {
        var EPSILON = 0.000001;
        this.nodes[0].pos.x = origin.x;
        this.nodes[0].pos.y = origin.y;
        for (var iN = 1; iN < this.nodes.length; iN++) {
            var dX = this.nodes[iN].pos.x - this.nodes[iN - 1].pos.x;
            var dY = this.nodes[iN].pos.y - this.nodes[iN - 1].pos.y;
            var distanceToPrevious = Math.sqrt(dX * dX + dY * dY);
            var correction = 0.5 * (1 - this.segmentLength / (distanceToPrevious + EPSILON));
            var correctionX = dX * correction;
            var correctionY = dY * correction;
            this.nodes[iN].pos.x -= correctionX;
            this.nodes[iN].pos.y -= correctionY;
            this.nodes[iN - 1].pos.x += correctionX;
            this.nodes[iN - 1].pos.y += correctionY;
        }
    };
    Rope.prototype.computeSmoothLine = function (minimumPoints) {
        var points = [];
        for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {
            var node = _a[_i];
            points.push(node.pos);
        }
        while (points.length < minimumPoints) {
            points = Rope.subdivideLine(points, 0.333);
        }
        return points;
    };
    Rope.subdivideLine = function (sourcePoints, ratio) {
        var newPoints = [];
        newPoints.push(sourcePoints[0]);
        for (var iP = 0; iP < sourcePoints.length - 1; iP++) {
            newPoints.push({
                x: sourcePoints[iP].x * (1 - ratio) + sourcePoints[iP + 1].x * ratio,
                y: sourcePoints[iP].y * (1 - ratio) + sourcePoints[iP + 1].y * ratio,
            });
            newPoints.push({
                x: sourcePoints[iP].x * ratio + sourcePoints[iP + 1].x * (1 - ratio),
                y: sourcePoints[iP].y * ratio + sourcePoints[iP + 1].y * (1 - ratio),
            });
        }
        newPoints.push(sourcePoints[sourcePoints.length - 1]);
        return newPoints;
    };
    return Rope;
}());
exports.Rope = Rope;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {
var exports = __webpack_exports__;
/*!************************!*\
  !*** ./src/ts/main.ts ***!
  \************************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
var flowers_manager_1 = __webpack_require__(/*! ./flowers-manager */ "./src/ts/flowers-manager.ts");
var force_field_1 = __webpack_require__(/*! ./force-field */ "./src/ts/force-field.ts");
var helpers_1 = __webpack_require__(/*! ./helpers */ "./src/ts/helpers.ts");
var parameters_1 = __webpack_require__(/*! ./parameters */ "./src/ts/parameters.ts");
var plotter_canvas_2d_1 = __webpack_require__(/*! ./plotting/plotter-canvas-2d */ "./src/ts/plotting/plotter-canvas-2d.ts");
var plotter_svg_1 = __webpack_require__(/*! ./plotting/plotter-svg */ "./src/ts/plotting/plotter-svg.ts");
__webpack_require__(/*! ./page-interface-generated */ "./src/ts/page-interface-generated.ts");
var plotter_canvas_webgl_1 = __webpack_require__(/*! ./plotting/plotter-canvas-webgl */ "./src/ts/plotting/plotter-canvas-webgl.ts");
function plot(flowersManager, plotter) {
    plotter.initialize(parameters_1.Parameters.backgroundColor, parameters_1.Parameters.linesColor, 0.2);
    flowersManager.draw(plotter);
    plotter.finalize();
}
function main() {
    var plotter = new plotter_canvas_webgl_1.PlotterCanvasWebGL() || new plotter_canvas_2d_1.PlotterCanvas2D();
    var flowersManager = new flowers_manager_1.FlowersManager();
    parameters_1.Parameters.addResetObserver(function () { flowersManager.reset(); });
    parameters_1.Parameters.addDownloadObserver(function () { exportAsSvg(flowersManager, plotter.width, plotter.height); });
    var maxDt = 1 / 60;
    var lastUpdate = performance.now();
    function mainLoop() {
        var now = performance.now();
        var dt = parameters_1.Parameters.speed * Math.min(maxDt, 0.001 * (now - lastUpdate));
        lastUpdate = now;
        plotter.adjustToCanvas();
        flowersManager.manage(plotter.width, plotter.height);
        var forceField = new force_field_1.ForceField(parameters_1.Parameters.mousePositionInPixels, 500);
        flowersManager.update(dt, forceField);
        plot(flowersManager, plotter);
        requestAnimationFrame(mainLoop);
    }
    requestAnimationFrame(mainLoop);
}
function exportAsSvg(flowersManager, width, height) {
    var plotter = new plotter_svg_1.PlotterSvg(width, height);
    plot(flowersManager, plotter);
    var svgText = plotter.toString();
    helpers_1.downloadTextFile("flowers.svg", svgText);
}
main();

}();
/******/ })()
;
//# sourceMappingURL=main.min.js.map